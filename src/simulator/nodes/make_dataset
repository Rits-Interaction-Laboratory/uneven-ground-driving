#!/usr/bin/env python

import time
import json
import random
import numpy as np

import rospy
from gazebo_msgs.msg import ModelState
from gazebo_msgs.srv import SetModelState
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
import cv2

from collections.abc import Callable
from position import Position, PositionRepository
from config import Config


cv_bridge = CvBridge()
position_repository = PositionRepository()

rospy.wait_for_service('/gazebo/set_model_state')
set_model_state: Callable = rospy.ServiceProxy('/gazebo/set_model_state', SetModelState)


def place_robot_on_random_position():
    """
    ロボットをランダムな位置に配置する
    """

    x_position: float = random.uniform(-5.0, 5.0)
    y_position: float = random.uniform(-5.0, 5.0)

    rospy.loginfo('Place robot on (%f, %f)' % (x_position, y_position))

    model_state = ModelState()
    model_state.model_name = Config.TURTLEBOT3_MODEL_NAME
    model_state.pose.position.x = x_position
    model_state.pose.position.y = y_position
    model_state.pose.position.z = 0.0

    model_state.pose.orientation.x = 0.0
    model_state.pose.orientation.y = 0.0
    model_state.pose.orientation.z = 0.0
    model_state.pose.orientation.w = 0.0

    set_model_state(model_state)


def odom_callback(msg: Odometry):
    """
    /odom トピックのコールバック関数
    """

    rospy.loginfo('Current Robot position is received from `/odom` topic.')

    position = Position(msg.pose.pose.position.x, msg.pose.pose.position.y, msg.pose.pose.position.z)
    position_repository.insert(position)


def depth_image_callback(msg: Image):
    """
    /camera/depth/image_raw トピックのコールバック関数
    """

    rospy.loginfo('Depth image is received from `/camera/depth/image_raw` topic.')

    try:
        depth_image = cv_bridge.imgmsg_to_cv2(msg)
        depth_array = np.array(depth_image, dtype=np.float32)
        cv2.normalize(depth_array, depth_array, 0, 1, cv2.NORM_MINMAX)
        cv2.imwrite('camera_image.jpeg', depth_array * 255)
    except CvBridgeError:
        rospy.logerr('Failed to save depth image.')


def save_measured_result():
    """
    測定結果を保存する
    """

    positions = position_repository.select_all()
    json_str = json.dumps({
        'positions': [position.to_json() for position in positions],
        'image_filename': 'XXX.png',
    })
    with open(Config.MEASURED_RESULT_FILENAME, 'a') as f:
        f.write(json_str + '\n')

    rospy.loginfo('Measured result is saved.')


if __name__ == "__main__":
    rospy.init_node('simulator')
    twist_topic = rospy.Publisher('cmd_vel', Twist, queue_size=10)

    # ロボットをランダムな位置に配置する
    position_repository.delete_all()
    place_robot_on_random_position()

    # ロボット位置を購読
    odometry_topic = rospy.Subscriber('/odom', Odometry, odom_callback)
    rospy.wait_for_message('/odom', Odometry)

    # TODO: 俯瞰した深度画像を撮影
    get_image_topic = rospy.Subscriber("/camera/depth/image_raw", Image, callback=depth_image_callback, queue_size=1)
    rospy.wait_for_message('/camera/depth/image_raw', Image)
    get_image_topic.unregister()

    # 一定時間ロボットを前進させる
    twist = Twist()
    twist.linear.x = Config.MAX_VELOCITY

    started_at = time.time()
    while (time.time() - started_at) < 3.0:
        twist_topic.publish(twist)
    odometry_topic.unregister()
    twist.linear.x = 0.0
    twist_topic.publish(twist)

    # 測定結果を記録する
    save_measured_result()
