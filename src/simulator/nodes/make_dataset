#!/usr/bin/env python

import time
import json
import random

import rospy
from gazebo_msgs.msg import ModelState
from gazebo_msgs.srv import SetModelState
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
import cv2

from collections.abc import Callable
from position import Position, PositionRepository


TURTLEBOT3_MODEL_NAME: str = "turtlebot3_waffle"
MAX_VELOCITY: float = 0.26

cv_bridge = CvBridge()
position_repository = PositionRepository()
set_model_state: Callable = rospy.ServiceProxy('/gazebo/set_model_state', SetModelState)


def place_roboto_on_random_position():
    """
    ロボットをランダムな位置に配置する
    """

    model_state = ModelState()
    model_state.model_name = TURTLEBOT3_MODEL_NAME
    model_state.pose.position.x = random.uniform(-5.0, 5.0)
    model_state.pose.position.y = random.uniform(-5.0, 5.0)
    model_state.pose.position.z = 0.0

    model_state.pose.orientation.x = 0.0
    model_state.pose.orientation.y = 0.0
    model_state.pose.orientation.z = 0.0
    model_state.pose.orientation.w = 0.0

    set_model_state(model_state)


def odom_callback(msg: Odometry):
    position = Position(msg.pose.pose.position.x, msg.pose.pose.position.y, msg.pose.pose.position.z)
    position_repository.insert(position)


def image_callback(msg: Image):
    try:
        cv2_img = cv_bridge.imgmsg_to_cv2(msg)
        cv2.imwrite('camera_image.jpeg', cv2_img)
    except CvBridgeError:
        print('Failed to save image.')


if __name__ == "__main__":
    rospy.init_node('simulator')
    twist_topic = rospy.Publisher('cmd_vel', Twist, queue_size=10)
    rospy.Subscriber('/odom', Odometry, odom_callback)
    # rospy.Subscriber("/camera/depth/image_raw", Image, callback=image_callback, queue_size=1)
    # rospy.spin()

    # TODO: 本アプリケーションにPub/Subはミスマッチ
    # なので、awaitを差し込みたい

    # ロボットをランダムな位置に配置する
    place_roboto_on_random_position()

    # TODO: 俯瞰した深度画像を撮影

    # 一定時間ロボットを前進させる
    twist = Twist()
    twist.linear.x = MAX_VELOCITY

    started_at = time.time()
    while (time.time() - started_at) < 2.0:
        twist_topic.publish(twist)

    twist.linear.x = 0.0
    twist_topic.publish(twist)
    time.sleep(0.1)

    # 測定結果を記録する
    # TODO: フレームごとのポジション配列が欲しい(n秒後はこの位置まで移動した、のような配列)
    # FIXME: init_positionは信頼できないっぽい？
    init_position = position_repository.select_oldest_position()
    final_position = position_repository.select_latest_position()
    json_str = json.dumps({
        'init_position': {
            'x': init_position.x,
            'y': init_position.y,
            'z': init_position.z,
        },
        'final_position': {
            'x': final_position.x,
            'y': final_position.y,
            'z': final_position.z,
        },
        'image_filename': 'XXX.png',
    })
    with open('data.jsonl', 'a') as f:
        f.write(json_str + '\n')
